Техническое задание: Отказоустойчивая обработка ошибок и повторные попыткиВерсия: 1.0Дата: 29 апреля 2025 г.1. ЦельПовысить надежность и отказоустойчивость системы генерации контента и медиа путем внедрения механизма обработки временных сбоев на ключевых этапах (инициация и проверка задач Midjourney, генерация видео Runway) с использованием счетчика повторных попыток перед окончательным признанием задачи неуспешной.2. Общая логикаПри возникновении ошибки на определенном этапе (например, ошибка API при запуске upscale), система не должна немедленно считать всю задачу проваленной или переходить к созданию имитации (mock).Вместо этого устанавливается специфический статус ошибки в config_midjourney.json.Вводится счетчик попыток для текущего generation_id.При последующих запусках b2_storage_manager.py проверяет статус ошибки и счетчик:Если лимит попыток не исчерпан, система пытается повторно выполнить только сбойный шаг.Если лимит попыток исчерпан, задача для данного generation_id считается окончательно неуспешной, generation_id очищается, и система готова к запуску новой задачи при следующем плановом запуске.Статус таймаута Midjourney (timed_out_mock_needed) обрабатывается отдельно и сразу приводит к генерации имитации, минуя логику повторных попыток.3. Предлагаемые изменения3.1. Файлы конфигурацииconfig.json:Добавить параметр в секцию WORKFLOW:"WORKFLOW": {
  // ... существующие параметры ...
  "max_retries": 3 // Макс. кол-во повторных попыток для одного шага
}
config_midjourney.json:Добавить поле retry_count (целое число, по умолчанию 0).Расширить возможные значения поля status для отражения конкретных ошибок:null (нет ошибки, ожидание)waiting_for_imagine (ожидание результата /imagine)waiting_for_upscale (ожидание результата /upscale)waiting_for_runway (ожидание результата Runway)imagine_trigger_failed (ошибка API при запуске /imagine)upscale_trigger_failed (ошибка API при запуске /upscale)mj_fetch_failed (ошибка API при проверке статуса MJ)runway_trigger_failed (ошибка API при запуске Runway)runway_poll_failed (ошибка API при проверке статуса Runway)runway_poll_timeout (таймаут ожидания Runway)timed_out_mock_needed (таймаут ожидания MJ - остается)task_failed_max_retries (финальный статус после исчерпания попыток)Пример структуры:{
  "midjourney_task": { ... } | null,
  "midjourney_results": { ... } | {},
  "generation": true | false,
  "status": "upscale_trigger_failed" | null | ...,
  "retry_count": 1 // Счетчик попыток для текущего статуса ошибки
}
3.2. Скрипт generate_media.pyОбработка ошибок API Midjourney:В функциях initiate_midjourney_task и trigger_piapi_action:При получении ошибки API (например, 500) или другого исключения, которое мешает запуску задачи:Не устанавливать generation: false немедленно.Вместо возврата None, функция должна вернуть словарь, указывающий на ошибку, например: {"error": true, "status_code": 500} или выбросить специфическое исключение.В основной логике generate_media.py (Сценарий 1 и Сценарий 2):При обработке результата initiate_midjourney_task или trigger_piapi_action:Если получена ошибка: Установить соответствующий статус в config_mj (imagine_trigger_failed или upscale_trigger_failed), установить retry_count: 0 (или инкрементировать, если это уже повторная попытка внутри скрипта - требует уточнения, проще сбрасывать в 0 здесь), сохранить config_mj и завершить скрипт (возможно, с ненулевым кодом выхода, чтобы сигнализировать менеджеру).Не переходить к следующим шагам (генерации сарказма, загрузке и т.д.), если запуск MJ/Upscale не удался.Обработка ошибок API/опроса Runway:В функции generate_runway_video:При ошибке API во время создания задачи (client.image_to_video.create): Установить status: "runway_trigger_failed", retry_count: 0 в config_mj и завершить скрипт.При ошибке API во время опроса статуса (client.tasks.retrieve): Установить status: "runway_poll_failed", retry_count: 0 в config_mj и завершить скрипт.При таймауте опроса: Установить status: "runway_poll_timeout", retry_count: 0 в config_mj и завершить скрипт.Важно: Не вызывать create_mock_video немедленно при этих ошибках. Генерация mock будет инициирована менеджером после исчерпания попыток или при статусе timed_out_mock_needed.3.3. Скрипт Workspace_media.pyОбработка ошибок API:В функции fetch_piapi_status:Если запрос к API (/mj/v2/fetch) завершается ошибкой (Timeout, RequestException, JSONDecodeError и т.д.):Функция должна вернуть специфический индикатор ошибки, например, {"error": "fetch_failed"} или None.В основной логике main():Если fetch_piapi_status вернул ошибку:Установить status: "mj_fetch_failed", retry_count: 0 в config_midjourney.json.Сохранить обновленный config_midjourney.json в B2.Завершить скрипт.3.4. Скрипт b2_storage_manager.pyДобавить чтение max_retries: В начале скрипта прочитать config.get("WORKFLOW.max_retries", 3).Изменить логику проверки состояний:Перед выполнением действия для сценариев 1, 2, 3, 4 (генерация контента, инициация MJ, проверка MJ, обработка результатов MJ/Runway) добавить проверку поля status в config_mj.Если status указывает на ошибку (например, upscale_trigger_failed, runway_poll_timeout и т.д., кроме timed_out_mock_needed):Прочитать retry_count из config_mj (если нет, считать 0).Если retry_count < max_retries:Логировать попытку повтора (например, "Попытка {retry_count + 1}/{max_retries} для статуса {status}").Увеличить retry_count на 1.Сбросить status на состояние, которое должно было быть перед ошибкой (например, если status == "upscale_trigger_failed", то сбросить status обратно на null или waiting_for_upscale, чтобы generate_media.py снова попытался запустить апскейл). Определить логику сброса для каждого типа ошибки.Сохранить обновленный config_midjourney.json в B2.Прервать текущую итерацию (continue или break в зависимости от того, нужно ли ждать следующего запуска по расписанию или пробовать сразу). Предпочтительнее break, чтобы не делать повторы слишком часто без необходимости.Если retry_count >= max_retries:Логировать достижение лимита попыток для generation_id.Установить финальный статус ошибки: status: "task_failed_max_retries" в config_mj.Сохранить обновленный config_midjourney.json в B2.Установить флаг task_failed = True (или использовать существующий task_completed_successfully = False).Прервать основной цикл (break). Переходим к завершению скрипта.Если status НЕ ошибка или null: Продолжить выполнение сценария как обычно.Если status == "timed_out_mock_needed": Выполнить Сценарий 0 (генерация mock) как и раньше, без логики retry.Изменить логику завершения задачи:Блок, который выполняется после основного цикла while.Проверять флаг task_failed (или инверсию task_completed_successfully).Если задача НЕ провалена (task_failed == False):Выполнить текущую логику: проверить task_completed_successfully, если True, то очистить generation_id в config_gen.json.Если задача провалена (task_failed == True):Логировать, что задача провалена после N попыток.Очистить generation_id в config_gen.json (чтобы система могла начать новую задачу в следующий раз).Не выполнять никаких действий, связанных с успешным завершением.Блок finally: Логика снятия блокировки (processing_lock: false) остается без изменений.4. Пример обновленного потока (Сбой Upscale)Запуск 1: ... -> generate_media -> Ошибка API при запуске Upscale -> generate_media сохраняет config_mj с status: "upscale_trigger_failed", retry_count: 0 -> b2_manager завершается.Запуск 2: b2_manager видит status: "upscale_trigger_failed". Проверяет retry_count (0) < max_retries (3). Инкрементирует retry_count до 1. Сбрасывает status на null (или waiting_for_upscale). Сохраняет config_mj. Завершается (break).Запуск 3: b2_manager видит status: null и наличие midjourney_results -> Запускает generate_media.Если generate_media снова сбоит: -> generate_media сохраняет config_mj с status: "upscale_trigger_failed", retry_count: 0 -> b2_manager завершается.Запуск 4: b2_manager видит status: "upscale_trigger_failed". Проверяет retry_count (1) < max_retries (3). Инкрементирует retry_count до 2. Сбрасывает status. Сохраняет config_mj. Завершается (break).... (Повторяется) ...Запуск N: b2_manager видит status: "upscale_trigger_failed". Проверяет retry_count (2) < max_retries (3). Инкрементирует retry_count до 3. Сбрасывает status. Сохраняет config_mj. Завершается (break).Запуск N+1: b2_manager видит status: "upscale_trigger_failed". Проверяет retry_count (3) >= max_retries (3). Устанавливает status: "task_failed_max_retries". Сохраняет config_mj. Устанавливает task_failed = True. Завершает цикл (break).Завершение скрипта: Блок после цикла видит task_failed = True. Очищает generation_id в config_gen.json. Снимает блокировку.Следующий основной запуск: b2_manager видит generation_id: null и начинает новую задачу.