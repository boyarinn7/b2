import os
import json
import sys
import subprocess
import openai
import requests
import base64
import time
import re
import random
import logging
from PIL import Image
from runwayml import RunwayML
from moviepy.editor import ImageClip, concatenate_videoclips
from modules.utils import ensure_directory_exists
from modules.logger import get_logger
from modules.error_handler import handle_error
from modules.config_manager import ConfigManager
from modules.api_clients import get_b2_client
from io import BytesIO

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
# === –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∏ –ª–æ–≥–≥–µ—Ä–∞ ===
config = ConfigManager()
logger = get_logger("generate_media")
logger.info("sys.path = " + str(sys.path))
os.makedirs("config", exist_ok=True)

# –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–∞—Ç–∞–ª–æ–≥ —Å–∫—Ä–∏–ø—Ç–∞ –∏ –¥–æ–±–∞–≤–ª—è–µ–º —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π –∫–∞—Ç–∞–ª–æ–≥ –≤ sys.path
script_dir = os.path.dirname(__file__)
parent_dir = os.path.abspath(os.path.join(script_dir, '..'))
sys.path.insert(0, parent_dir)

# –ü—É—Ç–∏ –∫ —Ñ–∞–π–ª–∞–º
CONFIG_GEN_PATH = "config/config_gen.json"
CONFIG_GEN_LOCAL_PATH = "config/config_gen.json"
CONFIG_MIDJOURNEY_PATH = "config/config_midjourney.json"  # –ë—ã–ª–æ CONFIG_MIDJOURNEY_REMOTE_PATH
CONFIG_MIDJOURNEY_LOCAL_PATH = "config/config_midjourney.json"
CONTENT_OUTPUT_PATH = "generated_content.json"
SCRIPTS_FOLDER = "scripts/"
B2_STORAGE_MANAGER_SCRIPT = os.path.join(SCRIPTS_FOLDER, "b2_storage_manager.py")
TARGET_FOLDER = "666/"
CONFIG_PUBLIC_PATH = "config/config_public.json"
CONFIG_PUBLIC_LOCAL_PATH = "config/config_public.json"

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞
USER_PROMPT_COMBINED = config.get("PROMPTS.user_prompt_combined")
OPENAI_MODEL = config.get("OPENAI_SETTINGS.model", "gpt-4o")
OPENAI_MAX_TOKENS = config.get("OPENAI_SETTINGS.max_tokens", 1000)
OPENAI_TEMPERATURE = config.get("OPENAI_SETTINGS.temperature", 0.7)
MIN_SCRIPT_LENGTH = config.get("VISUAL_ANALYSIS.min_script_length", 200)
IMAGE_SIZE = config.get("IMAGE_GENERATION.image_size", "1792x1024")
NUM_IMAGES = config.get("IMAGE_GENERATION.num_images", 1)
MIDJOURNEY_ENABLED = config.get("IMAGE_GENERATION.midjourney_enabled", True)
DALLE_ENABLED = config.get("IMAGE_GENERATION.dalle_enabled", True)
OUTPUT_IMAGE_FORMAT = config.get("PATHS.output_image_format", "png")
MIDJOURNEY_ENDPOINT = config.get("API_KEYS.midjourney.endpoint")
MIDJOURNEY_TASK_ENDPOINT = config.get("API_KEYS.midjourney.task_endpoint")
IMAGE_SELECTION_CRITERIA = config.get("VISUAL_ANALYSIS.image_selection_criteria", [])
MAX_ATTEMPTS = config.get("GENERATE.max_attempts", 3)

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫–ª—é—á–µ–π API
openai.api_key = os.getenv("OPENAI_API_KEY")
MIDJOURNEY_API_KEY = os.getenv("MIDJOURNEY_API_KEY")

if not openai.api_key:
    raise ValueError("API-–∫–ª—é—á OpenAI –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è OPENAI_API_KEY")
if MIDJOURNEY_ENABLED and not MIDJOURNEY_API_KEY:
    raise ValueError("API-–∫–ª—é—á Midjourney –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è MIDJOURNEY_API_KEY")

def split_midjourney_grid(url):
    try:
        # –°–∫–∞—á–∏–≤–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        response = requests.get(url, stream=True)
        response.raise_for_status()
        img = Image.open(BytesIO(response.content))

        # –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ —Å–µ—Ç–∫–∞ 2x2 —Ä–∞–≤–Ω—ã—Ö —á–∞—Å—Ç–µ–π
        width, height = img.size
        w, h = width // 2, height // 2

        # –î–µ–ª–∏–º –Ω–∞ 4 —á–∞—Å—Ç–∏
        images = [
            img.crop((0, 0, w, h)),  # –í–µ—Ä—Ö–Ω–∏–π –ª–µ–≤—ã–π
            img.crop((w, 0, width, h)),  # –í–µ—Ä—Ö–Ω–∏–π –ø—Ä–∞–≤—ã–π
            img.crop((0, h, w, height)),  # –ù–∏–∂–Ω–∏–π –ª–µ–≤—ã–π
            img.crop((w, h, width, height))  # –ù–∏–∂–Ω–∏–π –ø—Ä–∞–≤—ã–π
        ]

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Ç–∏
        temp_paths = []
        for i, sub_img in enumerate(images):
            temp_path = f"temp_midjourney_{i}.png"
            sub_img.save(temp_path)
            temp_paths.append(temp_path)

        logger.info("‚úÖ –°–µ—Ç–∫–∞ MidJourney —Ä–∞–∑–¥–µ–ª–µ–Ω–∞ –Ω–∞ 4 —á–∞—Å—Ç–∏")
        return temp_paths
    except Exception as e:
        handle_error(logger, "–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–∏ —Å–µ—Ç–∫–∏ MidJourney", e)
        return None

# === –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ===
def check_midjourney_results(b2_client):
    bucket_name = os.getenv("B2_BUCKET_NAME")
    if not bucket_name:
        raise ValueError("‚ùå –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è B2_BUCKET_NAME –Ω–µ –∑–∞–¥–∞–Ω–∞")
    remote_config = "config/config_public.json"
    temp_path = "temp_config.json"
    try:
        bucket = b2_client.get_bucket_by_name(bucket_name)
        bucket.download_file_by_name(remote_config, temp_path)
        with open(temp_path, 'r', encoding='utf-8') as f:
            config_data = json.load(f)
        os.remove(temp_path)
        return config_data.get("midjourney_results", None)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ midjourney_results: {e}")
        return None

def select_best_image(b2_client, image_urls, prompt):
    try:
        criteria = config.get("VISUAL_ANALYSIS.image_selection_criteria")
        selection_prompt = config.get("VISUAL_ANALYSIS.image_selection_prompt",
                                   "Select the best image based on the prompt '{prompt}' and these criteria: {criteria}")
        max_tokens = config.get("VISUAL_ANALYSIS.image_selection_max_tokens", 500)
        criteria_text = ", ".join([f"{c['name']} (weight: {c['weight']})" for c in criteria])
        full_prompt = selection_prompt.format(prompt=prompt, criteria=criteria_text)

        # –ï—Å–ª–∏ –æ–¥–∏–Ω URL, –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ —ç—Ç–æ —Å–µ—Ç–∫–∞
        if len(image_urls) == 1:
            logger.info("–û–±–Ω–∞—Ä—É–∂–µ–Ω –æ–¥–∏–Ω URL, —Ä–∞–∑–¥–µ–ª—è–µ–º —Å–µ—Ç–∫—É MidJourney")
            image_paths = split_midjourney_grid(image_urls[0])
            if not image_paths:
                logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑–¥–µ–ª–∏—Ç—å —Å–µ—Ç–∫—É, –≤—ã–±–∏—Ä–∞–µ–º –ø–µ—Ä–≤—ã–π URL")
                return image_urls[0]
        else:
            image_paths = image_urls  # –ï—Å–ª–∏ —É–∂–µ –æ—Ç–¥–µ–ª—å–Ω—ã–µ URL, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏—Ö

        for attempt in range(MAX_ATTEMPTS):
            try:
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã –≤ OpenAI
                message_content = [{"type": "text", "text": full_prompt}]
                for path in image_paths:
                    with open(path, "rb") as img_file:
                        base64_image = base64.b64encode(img_file.read()).decode("utf-8")
                        message_content.append({
                            "type": "image_url",
                            "image_url": {"url": f"data:image/png;base64,{base64_image}"}
                        })

                gpt_response = openai.ChatCompletion.create(
                    model=OPENAI_MODEL,
                    messages=[{"role": "user", "content": message_content}],
                    max_tokens=max_tokens
                )
                answer = gpt_response.choices[0].message.content
                logger.info(f"OpenAI –≤—ã–±–æ—Ä: {answer[:100]}...")
                best_index_match = re.search(r"Image (\d+)", answer)
                if best_index_match:
                    best_index = int(best_index_match.group(1)) - 1
                    if best_index in range(len(image_paths)):
                        best_url = image_urls[0] if len(image_urls) == 1 else image_paths[best_index]
                        # –û—á–∏—Å—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
                        if len(image_urls) == 1:
                            for path in image_paths:
                                if path != image_paths[best_index]:
                                    os.remove(path)
                        return image_paths[best_index] if len(image_urls) == 1 else best_url
                logger.error(f"–ù–µ–≤–µ—Ä–Ω—ã–π –∏–Ω–¥–µ–∫—Å –≤ –æ—Ç–≤–µ—Ç–µ OpenAI: {answer}, –≤—ã–±–∏—Ä–∞–µ–º –ø–µ—Ä–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ")
                return image_paths[0] if len(image_urls) == 1 else image_urls[0]
            except openai.error.OpenAIError as e:
                logger.error(f"–û—à–∏–±–∫–∞ OpenAI API (–ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{MAX_ATTEMPTS}): {e}")
                if attempt < MAX_ATTEMPTS - 1:
                    time.sleep(5)
                else:
                    logger.error("–ü—Ä–µ–≤—ã—à–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ OpenAI, –≤—ã–±–∏—Ä–∞–µ–º –ø–µ—Ä–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ")
                    return image_paths[0] if len(image_urls) == 1 else image_urls[0]
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ select_best_image: {e}")
        return image_urls[0]

def download_file_from_b2(b2_client, remote_path, local_path):
    bucket_name = "boyarinnbotbucket"
    max_attempts = 3
    if not bucket_name:
        raise ValueError("‚ùå –ò–º—è –±–∞–∫–µ—Ç–∞ –Ω–µ –∑–∞–¥–∞–Ω–æ")
    for attempt in range(max_attempts):
        try:
            logger.info(f"üîÑ –ü–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{max_attempts} –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞ –∏–∑ B2: {remote_path} -> {local_path}")
            ensure_directory_exists(os.path.dirname(local_path))
            bucket = b2_client.get_bucket_by_name(bucket_name)
            response = bucket.list_file_names(start_file_name=remote_path, max_file_count=1)
            exists = any(file_info['fileName'] == remote_path for file_info in response.get('files', []))
            if not exists:
                logger.error(f"‚ùå –§–∞–π–ª {remote_path} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ B2")
                raise FileNotFoundError(f"–§–∞–π–ª {remote_path} –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ –±–∞–∫–µ—Ç–µ {bucket_name}")
            bucket.download_file_by_name(remote_path, local_path)
            logger.info(f"‚úÖ –§–∞–π–ª '{remote_path}' —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω –≤ {local_path}")
            return
        except FileNotFoundError as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –Ω–∞ –ø–æ–ø—ã—Ç–∫–µ {attempt + 1}: {str(e)}")
            handle_error(logger, "B2 Download Error", e)
            raise
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –Ω–∞ –ø–æ–ø—ã—Ç–∫–µ {attempt + 1}: {str(e)}")
            if attempt < max_attempts - 1:
                time.sleep(2 ** attempt)
            else:
                handle_error(logger, "B2 Download Error", e)
                raise

def upload_to_b2(b2_client, folder, file_path):
    bucket_name = os.getenv("B2_BUCKET_NAME")
    if not bucket_name:
        raise ValueError("‚ùå –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è B2_BUCKET_NAME –Ω–µ –∑–∞–¥–∞–Ω–∞")
    try:
        file_name = os.path.basename(file_path)
        if not folder.endswith('/'):
            folder += '/'
        s3_key = f"{folder}{file_name}"
        logger.info(f"üîÑ –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞ –≤ B2: {file_path} -> {s3_key}")
        bucket = b2_client.get_bucket_by_name(bucket_name)
        bucket.upload_local_file(local_file=file_path, file_name=s3_key)
        logger.info(f"‚úÖ –§–∞–π–ª '{file_name}' —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω –≤ B2: {s3_key}")
        os.remove(file_path)
        logger.info(f"üóëÔ∏è –õ–æ–∫–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª {file_path} —É–¥–∞–ª—ë–Ω –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏.")
    except Exception as e:
        handle_error(logger, "B2 Upload Error", e)

def update_config_public(client, folder):
    bucket_name = os.getenv("B2_BUCKET_NAME")
    if not bucket_name:
        raise ValueError("‚ùå –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è B2_BUCKET_NAME –Ω–µ –∑–∞–¥–∞–Ω–∞")
    try:
        logger.info(f"üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ config_public.json: —É–¥–∞–ª–µ–Ω–∏–µ {folder} –∏–∑ —Å–ø–∏—Å–∫–∞ 'empty'")
        download_file_from_b2(client, CONFIG_PUBLIC_PATH, CONFIG_PUBLIC_LOCAL_PATH)
        with open(CONFIG_PUBLIC_LOCAL_PATH, 'r', encoding='utf-8') as file:
            config_public = json.load(file)
        if "empty" in config_public and folder in config_public["empty"]:
            config_public["empty"].remove(folder)
        with open(CONFIG_PUBLIC_LOCAL_PATH, 'w', encoding='utf-8') as file:
            json.dump(config_public, file, ensure_ascii=False, indent=4)
        bucket = client.get_bucket_by_name(bucket_name)
        bucket.upload_local_file(local_file=CONFIG_PUBLIC_LOCAL_PATH, file_name=CONFIG_PUBLIC_PATH)
        logger.info("‚úÖ config_public.json –æ–±–Ω–æ–≤–ª—ë–Ω –∏ –∑–∞–≥—Ä—É–∂–µ–Ω –æ–±—Ä–∞—Ç–Ω–æ –≤ B2.")
        os.remove(CONFIG_PUBLIC_LOCAL_PATH)
    except Exception as e:
        handle_error(logger, "Config Public Update Error", e)

def reset_processing_lock(client):
    bucket_name = os.getenv("B2_BUCKET_NAME")
    if not bucket_name:
        raise ValueError("‚ùå –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è B2_BUCKET_NAME –Ω–µ –∑–∞–¥–∞–Ω–∞")
    try:
        logger.info("üîÑ –°–±—Ä–æ—Å processing_lock –≤ config_public.json")
        download_file_from_b2(client, CONFIG_PUBLIC_PATH, CONFIG_PUBLIC_LOCAL_PATH)
        with open(CONFIG_PUBLIC_LOCAL_PATH, 'r', encoding='utf-8') as file:
            config_public = json.load(file)
        logger.info(f"–ü–µ—Ä–µ–¥ —Å–±—Ä–æ—Å–æ–º, processing_lock: {config_public.get('processing_lock')}")
        if config_public.get("processing_lock", False):
            config_public["processing_lock"] = False
        else:
            logger.info("processing_lock —É–∂–µ —Å–±—Ä–æ—à–µ–Ω.")
        with open(CONFIG_PUBLIC_LOCAL_PATH, 'w', encoding='utf-8') as file:
            json.dump(config_public, file, ensure_ascii=False, indent=4)
        bucket = client.get_bucket_by_name(bucket_name)
        bucket.upload_local_file(local_file=CONFIG_PUBLIC_LOCAL_PATH, file_name=CONFIG_PUBLIC_PATH)
        logger.info("‚úÖ processing_lock —É—Å–ø–µ—à–Ω–æ —Å–±—Ä–æ—à–µ–Ω –≤ config_public.json")
        download_file_from_b2(client, CONFIG_PUBLIC_PATH, CONFIG_PUBLIC_LOCAL_PATH)
        with open(CONFIG_PUBLIC_LOCAL_PATH, 'r', encoding='utf-8') as file:
            new_config = json.load(file)
        logger.info(f"–ü–æ—Å–ª–µ —Å–±—Ä–æ—Å–∞, config_public: {json.dumps(new_config, ensure_ascii=False)}")
        os.remove(CONFIG_PUBLIC_LOCAL_PATH)
    except Exception as e:
        handle_error(logger, "Processing Lock Reset Error", e)

def generate_script_and_frame(topic):
    creative_prompts = config.get("creative_prompts")
    if not creative_prompts or not isinstance(creative_prompts, list):
        logger.error(f"‚ùå –û—à–∏–±–∫–∞: 'creative_prompts' –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Å–ø–∏—Å–∫–æ–º")
        raise ValueError("–°–ø–∏—Å–æ–∫ 'creative_prompts' –Ω–µ –Ω–∞–π–¥–µ–Ω")
    for attempt in range(MAX_ATTEMPTS):
        try:
            selected_prompt = random.choice(creative_prompts)
            logger.info(f"‚ú® –í—ã–±—Ä–∞–Ω —Ç–≤–æ—Ä—á–µ—Å–∫–∏–π –ø–æ–¥—Ö–æ–¥: '{selected_prompt}'")
            combined_prompt = USER_PROMPT_COMBINED.replace("{topic}", topic).replace(
                "–ó–∞—Ç–µ–º –≤—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω —Ç–≤–æ—Ä—á–µ—Å–∫–∏–π –ø–æ–¥—Ö–æ–¥ –∏–∑ 'creative_prompts' –≤ –∫–æ–Ω—Ñ–∏–≥–µ",
                f"–ó–∞—Ç–µ–º –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–≤–æ—Ä—á–µ—Å–∫–∏–π –ø–æ–¥—Ö–æ–¥: '{selected_prompt}'"
            )
            logger.info(f"üîé –ü–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{MAX_ATTEMPTS}: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ü–µ–Ω–∞—Ä–∏—è –¥–ª—è '{topic[:100]}'...")
            response = openai.ChatCompletion.create(
                model=OPENAI_MODEL,
                messages=[{"role": "user", "content": combined_prompt}],
                max_tokens=OPENAI_MAX_TOKENS,
                temperature=OPENAI_TEMPERATURE,
            )
            combined_response = response['choices'][0]['message']['content'].strip()
            if len(combined_response) < MIN_SCRIPT_LENGTH:
                logger.error(f"‚ùå –û—Ç–≤–µ—Ç —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π: {len(combined_response)} —Å–∏–º–≤–æ–ª–æ–≤")
                continue
            if "First Frame Description:" not in combined_response or "End of Description" not in combined_response:
                logger.error("‚ùå –ú–∞—Ä–∫–µ—Ä—ã –∫–∞–¥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ –æ—Ç–≤–µ—Ç–µ!")
                continue
            script_text = combined_response.split("First Frame Description:")[0].strip()
            first_frame_description = combined_response.split("First Frame Description:")[1].split("End of Description")[0].strip()
            logger.info(f"üé¨ –°—Ü–µ–Ω–∞—Ä–∏–π: {script_text[:100]}...")
            logger.info(f"üñºÔ∏è –û–ø–∏—Å–∞–Ω–∏–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞: {first_frame_description[:100]}...")
            return script_text, first_frame_description
        except Exception as e:
            handle_error(logger, f"Script Generation Error (–ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{MAX_ATTEMPTS})", e)
            if attempt == MAX_ATTEMPTS - 1:
                logger.error("‚ùå –ü—Ä–µ–≤—ã—à–µ–Ω–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å—Ü–µ–Ω–∞—Ä–∏—è.")
                return None, None
    return None, None

def load_config_public(b2_client):
    bucket_name = os.getenv("B2_BUCKET_NAME")
    local_path = CONFIG_PUBLIC_LOCAL_PATH
    try:
        bucket = b2_client.get_bucket_by_name(bucket_name)
        os.makedirs(os.path.dirname(local_path), exist_ok=True)
        bucket.download_file_by_name(CONFIG_PUBLIC_PATH, local_path)
        with open(local_path, 'r', encoding='utf-8') as file:
            return json.load(file)
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ config_public.json: {e}")
        return {}

def save_config_public(b2_client, data):
    bucket_name = os.getenv("B2_BUCKET_NAME")
    try:
        with open(CONFIG_PUBLIC_LOCAL_PATH, 'w', encoding='utf-8') as file:
            json.dump(data, file, ensure_ascii=False, indent=4)
        bucket = b2_client.get_bucket_by_name(bucket_name)
        bucket.upload_local_file(local_file=CONFIG_PUBLIC_LOCAL_PATH, file_name=CONFIG_PUBLIC_PATH)
        logger.info("‚úÖ config_public.json —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ B2.")
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è config_public.json: {e}")

def load_config_midjourney(client):
    bucket_name = os.getenv("B2_BUCKET_NAME")
    try:
        bucket = client.get_bucket_by_name(bucket_name)
        bucket.download_file_by_name(CONFIG_MIDJOURNEY_PATH, CONFIG_MIDJOURNEY_LOCAL_PATH)
        with open(CONFIG_MIDJOURNEY_LOCAL_PATH, 'r', encoding='utf-8') as file:
            return json.load(file)
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è –ö–æ–Ω—Ñ–∏–≥ {CONFIG_MIDJOURNEY_PATH} –Ω–µ –Ω–∞–π–¥–µ–Ω, —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π: {e}")
        return {"midjourney_task": None}

def save_config_midjourney(b2_client, data):
    bucket_name = os.getenv("B2_BUCKET_NAME")
    try:
        with open(CONFIG_MIDJOURNEY_LOCAL_PATH, 'w', encoding='utf-8') as file:
            json.dump(data, file, ensure_ascii=False, indent=4)
        bucket = b2_client.get_bucket_by_name(bucket_name)
        bucket.upload_local_file(local_file=CONFIG_MIDJOURNEY_LOCAL_PATH, file_name=CONFIG_MIDJOURNEY_PATH)
        logger.info(f"‚úÖ config_midjourney.json —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ B2: {json.dumps(data, ensure_ascii=False)}")
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è config_midjourney.json: {e}")
        raise

# –û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è generate_image_with_midjourney —Å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ–º
def generate_image_with_midjourney(prompt, generation_id, target_folder):
    b2_client = get_b2_client()
    try:
        headers = {
            "X-API-Key": MIDJOURNEY_API_KEY,
            "Content-Type": "application/json"
        }
        payload = {
            "model": "midjourney",
            "task_type": "imagine",
            "input": {
                "prompt": prompt,
                "aspect_ratio": "16:9",
                "process_mode": "v5"
            }
        }
        logger.info(f"–ó–∞–ø—Ä–æ—Å –∫ MidJourney: {prompt[:100]}...")
        response = requests.post(MIDJOURNEY_ENDPOINT, json=payload, headers=headers, timeout=30)
        response.raise_for_status()
        response_json = response.json()
        task_id = response_json.get("data", {}).get("task_id")
        if not task_id:
            raise ValueError(f"–ö–ª—é—á 'task_id' –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ 'data' –æ—Ç–≤–µ—Ç–∞: {response.text}")

        config_midjourney = load_config_midjourney(b2_client)
        config_midjourney["midjourney_task"] = {
            "task_id": task_id,
            "sent_at": int(time.time())
        }
        save_config_midjourney(b2_client, config_midjourney)
        logger.info(f"‚úÖ –ó–∞–¥–∞—á–∞ {task_id} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –≤ MidJourney –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ config_midjourney.json")

        # –ó–∞–ø—É—Å–∫ b2_storage_manager.py
        if not os.path.isfile(B2_STORAGE_MANAGER_SCRIPT):
            raise FileNotFoundError(f"‚ùå –°–∫—Ä–∏–ø—Ç {B2_STORAGE_MANAGER_SCRIPT} –Ω–µ –Ω–∞–π–¥–µ–Ω")
        logger.info(f"üîÑ –ó–∞–ø—É—Å–∫ —Å–∫—Ä–∏–ø—Ç–∞: {B2_STORAGE_MANAGER_SCRIPT}")
        subprocess.run([sys.executable, B2_STORAGE_MANAGER_SCRIPT], check=True)

    except (requests.exceptions.RequestException, ValueError) as e:
        logger.error(f"–û—à–∏–±–∫–∞ MidJourney: {e}")
        if 'response' in locals():
            logger.error(f"–¢–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞: {response.text}")
        if DALLE_ENABLED:
            logger.warning("‚ö†Ô∏è MidJourney –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª, –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ DALL¬∑E 3")
            image_path = generate_image_with_dalle(prompt, generation_id)
            if image_path:
                logger.info(f"‚úÖ DALL¬∑E 3 —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: {image_path}")
                upload_to_b2(b2_client, target_folder, image_path)
                subprocess.run([sys.executable, B2_STORAGE_MANAGER_SCRIPT], check=True)
            else:
                raise Exception("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —á–µ—Ä–µ–∑ DALL¬∑E 3")
        else:
            raise Exception("MidJourney –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª, –∏ DALL¬∑E 3 –æ—Ç–∫–ª—é—á–µ–Ω")

def remove_midjourney_results(b2_client):
    bucket_name = os.getenv("B2_BUCKET_NAME")
    remote_config = "config/config_public.json"
    temp_path = "temp_config.json"
    try:
        bucket = b2_client.get_bucket_by_name(bucket_name)
        bucket.download_file_by_name(remote_config, temp_path)
        with open(temp_path, 'r', encoding='utf-8') as f:
            config_data = json.load(f)
        if "midjourney_results" in config_data:
            logger.info("–£–¥–∞–ª—è–µ–º –∫–ª—é—á midjourney_results –∏–∑ config_public.")
            del config_data["midjourney_results"]
            with open(temp_path, 'w', encoding='utf-8') as f:
                json.dump(config_data, f, ensure_ascii=False, indent=4)
            bucket.upload_local_file(local_file=temp_path, file_name=remote_config)
            logger.info("‚úÖ –ö–ª—é—á midjourney_results —É–¥–∞–ª—ë–Ω –∏–∑ config_public.")
        else:
            logger.info("–ö–ª—é—á midjourney_results –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ config_public, –Ω–∏—á–µ–≥–æ –Ω–µ —É–¥–∞–ª—è–µ–º.")
        os.remove(temp_path)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ midjourney_results: {e}")

def generate_image_with_dalle(prompt, generation_id):
    for attempt in range(MAX_ATTEMPTS):
        try:
            logger.info(f"üîÑ –ü–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{MAX_ATTEMPTS}: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —á–µ—Ä–µ–∑ DALL¬∑E 3: {prompt[:100]}...")
            response = openai.Image.create(
                prompt=prompt,
                n=NUM_IMAGES,
                size=IMAGE_SIZE,
                model="dall-e-3",
                response_format="b64_json"
            )
            image_data = response["data"][0]["b64_json"]
            image_path = f"{generation_id}.{OUTPUT_IMAGE_FORMAT}"
            with open(image_path, "wb") as f:
                f.write(base64.b64decode(image_data))
            with Image.open(image_path) as img:
                logger.info(f"‚úÖ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–æ–º: {img.size}")
            return image_path
        except Exception as e:
            handle_error(logger, f"DALL¬∑E Image Generation Error (–ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{MAX_ATTEMPTS})", e)
            if attempt == MAX_ATTEMPTS - 1:
                logger.error("‚ùå –ü—Ä–µ–≤—ã—à–µ–Ω–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ DALL¬∑E.")
                return None
    return None

# –û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è generate_image –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ target_folder
def generate_image(prompt, generation_id, target_folder):
    if MIDJOURNEY_ENABLED:
        logger.info("üé® –ò—Å–ø–æ–ª—å–∑—É–µ–º Midjourney –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è")
        generate_image_with_midjourney(prompt, generation_id, target_folder)
    elif DALLE_ENABLED:
        logger.info("üé® –ò—Å–ø–æ–ª—å–∑—É–µ–º DALL¬∑E 3 –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è")
        image_path = generate_image_with_dalle(prompt, generation_id)
        if image_path:
            upload_to_b2(get_b2_client(), target_folder, image_path)
    else:
        raise ValueError("–ù–∏ Midjourney, –Ω–∏ DALL¬∑E 3 –Ω–µ –≤–∫–ª—é—á–µ–Ω—ã –≤ –∫–æ–Ω—Ñ–∏–≥–µ")

def resize_existing_image(image_path):
    try:
        with Image.open(image_path) as img:
            resized = img.resize((1280, 768))
            resized.save(image_path)
        logger.info(f"‚úÖ –†–∞–∑–º–µ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω: {image_path}")
        return True
    except Exception as e:
        handle_error(logger, "Image Resize Error", e)
        return False

def load_content_from_b2(b2_client, generation_id):
    bucket_name = os.getenv("B2_BUCKET_NAME")
    remote_path = f"666/{generation_id}.json"
    local_path = f"temp_{generation_id}.json"
    try:
        download_file_from_b2(b2_client, remote_path, local_path)
        with open(local_path, 'r', encoding='utf-8') as f:
            content = json.load(f)
        os.remove(local_path)
        return content
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ 666/{generation_id}.json: {e}")
        sys.exit(1)

def clean_script_text(text):
    cleaned = text.replace('\n', ' ').replace('\r', ' ')
    cleaned = ' '.join(cleaned.split())
    return cleaned[:980]

def create_mock_video(image_path, output_path, duration=10):
    try:
        logger.info(f"üé• –°–æ–∑–¥–∞–Ω–∏–µ –∏–º–∏—Ç–∞—Ü–∏–∏ –≤–∏–¥–µ–æ –∏–∑ {image_path} –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é {duration} —Å–µ–∫")
        clip = ImageClip(image_path, duration=duration)
        clip.write_videofile(
            output_path,
            codec="libx264",
            fps=24,
            audio=False,
            logger=None
        )
        logger.info(f"‚úÖ –ò–º–∏—Ç–∞—Ü–∏—è –≤–∏–¥–µ–æ —Å–æ–∑–¥–∞–Ω–∞: {output_path}")
        return output_path
    except Exception as e:
        handle_error(logger, "Mock Video Creation Error", e)
        return None

def generate_runway_video(image_path, script_text):
    api_key = os.getenv("RUNWAY_API_KEY")
    if not api_key:
        logger.error("‚ùå RUNWAY_API_KEY –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")
        return None
    try:
        with open(image_path, "rb") as img_file:
            base64_image = base64.b64encode(img_file.read()).decode("utf-8")
        client = RunwayML(api_key=api_key)
        task = client.image_to_video.create(
            model="gen4",
            prompt_image=f"data:image/png;base64,{base64_image}",
            prompt_text=script_text,
            duration=10,
            ratio="1280:768"
        )
        logger.info(f"‚úÖ –ó–∞–¥–∞—á–∞ Runway —Å–æ–∑–¥–∞–Ω–∞. ID: {task.id}")
        while True:
            status = client.tasks.retrieve(task.id)
            if status.status == "SUCCEEDED":
                logger.info("‚úÖ –í–∏–¥–µ–æ —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ")
                return status.output[0]  # URL –Ω–∞—Å—Ç–æ—è—â–µ–≥–æ –≤–∏–¥–µ–æ
            elif status.status == "FAILED":
                logger.error("‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ –≤ Runway")
                return None
            time.sleep(5)
    except Exception as e:
        error_msg = str(e)
        if "credits" in error_msg.lower():
            logger.warning(f"‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ–∫ –∫—Ä–µ–¥–∏—Ç–æ–≤ –≤ Runway: {error_msg}")
            video_path = image_path.replace(".png", ".mp4")
            mock_video = create_mock_video(image_path, video_path)
            if mock_video:
                logger.info(f"üîÑ –ó–∞–º–µ–Ω–∞: —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–∞ –∏–º–∏—Ç–∞—Ü–∏—è –≤–∏–¥–µ–æ: {mock_video}")
                return mock_video
        handle_error(logger, "Runway Video Generation Error", e)
        return None

def download_video(url, output_path):
    try:
        response = requests.get(url, stream=True)
        response.raise_for_status()
        with open(output_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        logger.info(f"‚úÖ –í–∏–¥–µ–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {output_path}")
        return True
    except Exception as e:
        handle_error(logger, "Video Download Error", e)
        return False

# === –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è ===
def main():
    logger.info("üîÑ –ù–∞—á–∞–ª–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –º–µ–¥–∏–∞...")
    import argparse
    parser = argparse.ArgumentParser(description="Generate Media")
    parser.add_argument("--generation_id", type=str, required=True, help="ID for content generation")
    args = parser.parse_args()

    try:
        b2_client = get_b2_client()
        if not b2_client:
            raise Exception("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∫–ª–∏–µ–Ω—Ç B2")

        generation_id = args.generation_id
        logger.info(f"üìÇ ID –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {generation_id}")

        # –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –∏–∑ B2 (666/<generation_id>.json)
        generated_content = load_content_from_b2(b2_client, generation_id)
        topic_data = generated_content.get("topic", "")
        if isinstance(topic_data, dict):
            topic = topic_data.get("full_topic", "")
        else:
            topic = topic_data or generated_content.get("content", "")
        if not topic:
            raise ValueError("–¢–µ–º–∞ –∏–ª–∏ —Ç–µ–∫—Å—Ç –ø–æ—Å—Ç–∞ –ø—É—Å—Ç—ã!")
        script_text = generated_content.get("script", "")
        first_frame_description = generated_content.get("first_frame_description", "")
        if not script_text or not first_frame_description:
            raise ValueError(f"–°—Ü–µ–Ω–∞—Ä–∏–π –∏–ª–∏ –æ–ø–∏—Å–∞–Ω–∏–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –≤ 666/{generation_id}.json")

        # –ó–∞–≥—Ä—É–∑–∫–∞ config_midjourney.json –∏–∑ B2
        download_file_from_b2(b2_client, CONFIG_MIDJOURNEY_PATH, CONFIG_MIDJOURNEY_LOCAL_PATH)
        with open(CONFIG_MIDJOURNEY_LOCAL_PATH, 'r', encoding='utf-8') as f:
            config_midjourney = json.load(f)
        midjourney_results = config_midjourney.get("midjourney_results", {})

        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π TARGET_FOLDER
        target_folder = TARGET_FOLDER

        # –°—Ü–µ–Ω–∞—Ä–∏–π 1: –ï—Å—Ç—å midjourney_results
        if midjourney_results and "image_urls" in midjourney_results:
            image_urls = midjourney_results.get("image_urls", [])
            if not image_urls or not all(isinstance(url, str) and url.startswith("http") for url in image_urls):
                logger.warning("‚ö†Ô∏è –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ URL –≤ midjourney_results, –æ—á–∏—â–∞–µ–º –∫–ª—é—á")
                config_midjourney["midjourney_results"] = {}
                with open(CONFIG_MIDJOURNEY_LOCAL_PATH, 'w', encoding='utf-8') as f:
                    json.dump(config_midjourney, f, ensure_ascii=False, indent=4)
                upload_to_b2(b2_client, os.path.dirname(CONFIG_MIDJOURNEY_PATH), CONFIG_MIDJOURNEY_LOCAL_PATH)
            else:
                import shutil

                # –í—ã–±–æ—Ä –ª—É—á—à–µ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
                best_image_path = select_best_image(b2_client, image_urls, first_frame_description)
                image_path = f"{generation_id}.{OUTPUT_IMAGE_FORMAT}"

                if best_image_path.startswith("http"):
                    response = requests.get(best_image_path, stream=True)
                    response.raise_for_status()
                    with open(image_path, "wb") as f:
                        f.write(response.content)
                else:
                    shutil.move(best_image_path, image_path)

                logger.info(f"‚úÖ –õ—É—á—à–µ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {image_path}")

                # –£–¥–∞–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
                for i in range(4):
                    temp_path = f"temp_midjourney_{i}.png"
                    if os.path.exists(temp_path):
                        os.remove(temp_path)
                        logger.info(f"üóëÔ∏è –£–¥–∞–ª—ë–Ω –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª: {temp_path}")

                # –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
                if not resize_existing_image(image_path):
                    raise ValueError("–ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–º–µ–Ω–∏—Ç—å —Ä–∞–∑–º–µ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è")

                # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ
                cleaned_script = clean_script_text(script_text)
                video_result = generate_runway_video(image_path, cleaned_script)
                video_path = None
                if video_result:
                    if video_result.startswith("http"):
                        video_path = f"{generation_id}.mp4"
                        if not download_video(video_result, video_path):
                            logger.warning("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ")
                    else:
                        video_path = video_result
                        logger.info(f"üîÑ –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏–º–∏—Ç–∞—Ü–∏—é –≤–∏–¥–µ–æ: {video_path}")

                # –ó–∞–≥—Ä—É–∑–∫–∞ –≤ B2
                upload_to_b2(b2_client, target_folder, image_path)
                if video_path and os.path.exists(video_path):
                    upload_to_b2(b2_client, target_folder, video_path)

                # –û—á–∏—Å—Ç–∫–∞ midjourney_results
                config_midjourney["midjourney_results"] = {}
                with open(CONFIG_MIDJOURNEY_LOCAL_PATH, 'w', encoding='utf-8') as f:
                    json.dump(config_midjourney, f, ensure_ascii=False, indent=4)
                upload_to_b2(b2_client, os.path.dirname(CONFIG_MIDJOURNEY_PATH), CONFIG_MIDJOURNEY_LOCAL_PATH)

                # –ó–∞–ø—É—Å–∫ b2_storage_manager.py
                if not os.path.isfile(B2_STORAGE_MANAGER_SCRIPT):
                    raise FileNotFoundError(f"‚ùå –°–∫—Ä–∏–ø—Ç {B2_STORAGE_MANAGER_SCRIPT} –Ω–µ –Ω–∞–π–¥–µ–Ω")
                logger.info(f"üîÑ –ó–∞–ø—É—Å–∫ —Å–∫—Ä–∏–ø—Ç–∞: {B2_STORAGE_MANAGER_SCRIPT}")
                subprocess.run([sys.executable, B2_STORAGE_MANAGER_SCRIPT], check=True)

        # –°—Ü–µ–Ω–∞—Ä–∏–π 2: –ù–µ—Ç midjourney_results
        else:
            # –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–¥–∞—á–∏ MidJourney
            generate_image(first_frame_description, generation_id, target_folder)
            # –ó–∞–ø—É—Å–∫ b2_storage_manager.py —É–∂–µ –≤–Ω—É—Ç—Ä–∏ generate_image

    except Exception as e:
        handle_error(logger, "–û—à–∏–±–∫–∞ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏", e)
        raise

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.info("üõë –ü—Ä–æ–≥—Ä–∞–º–º–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º.")
    except Exception as e:
        logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
        sys.exit(1)